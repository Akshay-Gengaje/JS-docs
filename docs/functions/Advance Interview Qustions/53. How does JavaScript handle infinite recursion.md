# How does JavaScript handle infinite recursion?

## **‚úÖ What is Infinite Recursion?**  
Infinite recursion occurs when a recursive function **keeps calling itself indefinitely** **without a proper base case**, leading to a **stack overflow error**.

### **üö® Example of Infinite Recursion**
```javascript
function infiniteRecursion() {
    console.log("This will run forever...");
    infiniteRecursion(); // ‚ùå No base case
}

infiniteRecursion(); // ‚ùå Uncaught RangeError: Maximum call stack size exceeded
```
üìå **Key Problem:**  
‚úî There is **no stopping condition (base case)**.  
‚úî The function **keeps adding new stack frames** until the **call stack limit** is exceeded.  

---

## **‚úÖ How JavaScript Handles Infinite Recursion?**
JavaScript uses a **call stack**, a memory structure that keeps track of function calls. When recursion **does not terminate**, the call stack **overflows**, causing a **RangeError**.

### **üõë Example: Stack Overflow Error**
```javascript
function recurse() {
    recurse(); // ‚ùå No base case
}

recurse(); // ‚ùå Uncaught RangeError: Maximum call stack size exceeded
```
üìå **Key Takeaways:**  
‚úî Each recursive call adds a **new stack frame**.  
‚úî If there‚Äôs **no base case**, it **never stops**.  
‚úî **Once the stack is full, JavaScript throws a `RangeError`.**  

---

## **‚úÖ How to Prevent Infinite Recursion?**
### **1Ô∏è‚É£ Add a Base Case**
A **base case** stops the recursion when a certain condition is met.

```javascript
function countdown(n) {
    if (n <= 0) return; // ‚úÖ Base case
    console.log(n);
    countdown(n - 1); // Recursive call
}

countdown(5); // ‚úÖ Works fine
```
‚úî **Prevents infinite recursion** by stopping at `n === 0`.  

---

### **2Ô∏è‚É£ Use Iteration Instead of Recursion**
If recursion is not required, use a **loop** instead.

```javascript
function countdown(n) {
    while (n > 0) {
        console.log(n);
        n--;
    }
}

countdown(5); // ‚úÖ Works without stack overflow
```
‚úî **Loops** do not use extra stack frames, avoiding stack overflow.  

---

### **3Ô∏è‚É£ Implement Tail Recursion (If Supported)**
Using **tail recursion** (where the recursive call is the last operation) can prevent excessive stack usage **if Tail Call Optimization (TCO) is supported**.

```javascript
"use strict";
function tailRecursion(n, acc = 1) {
    if (n === 1) return acc;
    return tailRecursion(n - 1, n * acc); // ‚úÖ Tail recursive
}

console.log(tailRecursion(5)); // ‚úÖ Works in some JavaScript engines
```
‚úî **Only works in JavaScript engines that support TCO (e.g., Safari)**.  

---

### **4Ô∏è‚É£ Use SetTimeout to Avoid Blocking the Stack**
If recursion is necessary but might go too deep, break it up using `setTimeout()`.

```javascript
function delayedRecursion(n) {
    if (n <= 0) return;
    console.log(n);
    setTimeout(() => delayedRecursion(n - 1), 0); // ‚úÖ Prevents stack overflow
}

delayedRecursion(1000000); // ‚úÖ No stack overflow
```
‚úî **Each recursive call is scheduled asynchronously**, avoiding stack overflow.  

---

## **üöÄ Summary**
| **Issue** | **How to Fix** |
|-----------|--------------|
| **Infinite recursion** | Add a **base case** to stop recursion |
| **Stack overflow error** | Use **loops instead of recursion** |
| **Deep recursion issues** | Use **tail recursion** (only if supported) |
| **Long-running recursion** | Use **setTimeout** to prevent stack blocking |

---
