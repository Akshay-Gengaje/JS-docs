# What happens when you define a function inside a loop?

When you define a function inside a loop, it creates **a new function in each iteration**, leading to potential performance and scope-related issues. The behavior depends on whether you use **var, let, or const** inside the loop.

---

## **âœ… Example 1: Using `var` Inside a Loop**
```javascript
for (var i = 0; i < 3; i++) {
    function show() {
        console.log(i);
    }
    show();
}
```
### **ðŸ”¹ Execution Steps:**
1ï¸âƒ£ `i = 0 â†’ show() prints 0`  
2ï¸âƒ£ `i = 1 â†’ show() prints 1`  
3ï¸âƒ£ `i = 2 â†’ show() prints 2`  

âœ” **Final Output:**
```
0
1
2
```
ðŸ“Œ Since `var` is function-scoped, the function **always refers to the latest value of `i`**.

---

## **âœ… Example 2: Function Inside `setTimeout` with `var`**
```javascript
for (var i = 0; i < 3; i++) {
    setTimeout(function () {
        console.log(i);
    }, 100);
}
```
### **ðŸ”¹ Execution Steps:**
1ï¸âƒ£ The loop runs, setting `i = 0, 1, 2`, then exits with `i = 3`.  
2ï¸âƒ£ All `setTimeout` functions execute **after the loop finishes**.  
3ï¸âƒ£ Each function accesses `i`, which is now `3`.  

âœ” **Final Output (after 100ms delay):**
```
3
3
3
```
ðŸ“Œ **Why?**  
- `var` is function-scoped, so all functions **share the same `i`**.
- When `setTimeout` executes, `i = 3`.

### **âœ… Solution: Use an IIFE or `let`**
```javascript
for (var i = 0; i < 3; i++) {
    (function (j) {
        setTimeout(function () {
            console.log(j);
        }, 100);
    })(i);
}
```
âœ” **Output:**  
```
0
1
2
```
ðŸ“Œ Here, an **Immediately Invoked Function Expression (IIFE)** captures the current value of `i` using `j`.

---

## **âœ… Example 3: Using `let` Inside a Loop**
```javascript
for (let i = 0; i < 3; i++) {
    function show() {
        console.log(i);
    }
    show();
}
```
âœ” **Output:**
```
0
1
2
```
ðŸ“Œ **Why?**  
- `let` is **block-scoped**, so a new `i` is created **for each iteration**.

---

## **âœ… Example 4: Function Inside `setTimeout` with `let`**
```javascript
for (let i = 0; i < 3; i++) {
    setTimeout(function () {
        console.log(i);
    }, 100);
}
```
âœ” **Output (after 100ms delay):**
```
0
1
2
```
ðŸ“Œ **Why?**  
- `let` creates a **new scope** for each loop iteration.
- Each function **remembers its own `i`**.

---

## **âœ… Key Takeaways**
| Feature | `var` | `let` |
|---------|------|------|
| Scope | Function-scoped | Block-scoped |
| Functions inside a loop | Share the same variable | Each iteration gets a new copy |
| Behavior in `setTimeout` | Uses last updated value | Uses correct value per iteration |

---

## **ðŸš€ Summary**
âœ” **Avoid defining functions inside loops unless necessary.**  
âœ” **Use `let` instead of `var`** to ensure correct values inside functions.  
âœ” **For `var`, use an IIFE** to capture the correct value.  
âœ” **Be cautious with memory usage** when defining functions inside loops.  
