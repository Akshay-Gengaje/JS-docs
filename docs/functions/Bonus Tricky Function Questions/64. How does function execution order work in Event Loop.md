# How does function execution order work in Event Loop?

The **JavaScript Event Loop** is what allows JavaScript to handle asynchronous operations **non-blockingly** while still being **single-threaded**. It ensures that the JavaScript engine executes tasks **in the correct order** and does not block execution.

---

# **âœ… Step 1: Understanding the Call Stack**  
JavaScript uses a **Call Stack** to keep track of function execution.  
ðŸ“Œ **Call Stack Behavior:**  
- Functions are pushed onto the stack when called.  
- They are popped off when they return a value.  
- JavaScript executes **synchronously** until the stack is empty.  

### **ðŸ”¹ Example**
```javascript
function foo() {
    console.log("foo");
}
function bar() {
    console.log("bar");
    foo();
}
bar();
```
### **ðŸ”¹ Execution Order**
1ï¸âƒ£ `bar()` is pushed onto the stack.  
2ï¸âƒ£ `"bar"` is logged.  
3ï¸âƒ£ `foo()` is called, so it is pushed onto the stack.  
4ï¸âƒ£ `"foo"` is logged.  
5ï¸âƒ£ `foo()` returns, so it is popped off.  
6ï¸âƒ£ `bar()` returns, so it is popped off.  

âœ” **Final Output:**  
```
bar
foo
```
---

# **âœ… Step 2: Event Loop & Asynchronous Tasks**  
JavaScript runs **synchronous** tasks first and **defers** asynchronous tasks.  
These tasks are handled by the **Event Loop**, which consists of:  
1ï¸âƒ£ **Call Stack** (Executes synchronous code)  
2ï¸âƒ£ **Web APIs** (Handles asynchronous tasks like timers, fetch, I/O, etc.)  
3ï¸âƒ£ **Task Queues** (Microtask Queue & Callback Queue)  

---

# **âœ… Step 3: Task Queues**
There are **two main queues** in the Event Loop:

### **1ï¸âƒ£ MacroTask Queue (Callback Queue)**
Handles:  
âœ” `setTimeout`  
âœ” `setInterval`  
âœ” `setImmediate` (Node.js)  
âœ” `I/O operations` (File reading, network requests)  
âœ” UI rendering events  

### **2ï¸âƒ£ MicroTask Queue (Promise Queue)**
Handles:  
âœ” `Promises` (`.then()`, `.catch()`)  
âœ” `MutationObserver` (DOM changes)  
âœ” `process.nextTick()` (Node.js - higher priority than Promises)  

ðŸ”¹ **Microtasks execute before macrotasks!**  

---

# **âœ… Step 4: The Event Loop Execution Order**
1ï¸âƒ£ **Execute all synchronous code first (Call Stack).**  
2ï¸âƒ£ **Process Microtasks** (Promise `.then()`, `process.nextTick()`).  
3ï¸âƒ£ **Execute the first Macrotask** (from the Callback Queue).  
4ï¸âƒ£ **Repeat (Microtasks first, then next Macrotask).**  

---

# **âœ… Step 5: Code Execution Order Example**
```javascript
console.log("Start");

setTimeout(() => {
    console.log("setTimeout");
}, 0);

Promise.resolve().then(() => {
    console.log("Promise");
});

console.log("End");
```
### **ðŸ”¹ Execution Steps**
1ï¸âƒ£ `"Start"` logs (synchronous).  
2ï¸âƒ£ `setTimeout` is **registered** and moves to the Macrotask queue.  
3ï¸âƒ£ `Promise.then()` moves to the **Microtask queue**.  
4ï¸âƒ£ `"End"` logs (synchronous).  
5ï¸âƒ£ **Microtask queue executes first â†’ `"Promise"` logs.**  
6ï¸âƒ£ **Macrotask queue executes â†’ `"setTimeout"` logs.**  

âœ” **Final Output:**  
```
Start
End
Promise
setTimeout
```

---

# **âœ… Step 6: Nested Event Loop Behavior**
```javascript
console.log("A");

setTimeout(() => console.log("B"), 0);

Promise.resolve().then(() => {
    console.log("C");
    return Promise.resolve("D");
}).then(console.log);

console.log("E");
```
### **ðŸ”¹ Execution Order**
1ï¸âƒ£ `"A"` logs.  
2ï¸âƒ£ `setTimeout` moves to the **Macrotask queue**.  
3ï¸âƒ£ `Promise.then()` moves to the **Microtask queue**.  
4ï¸âƒ£ `"E"` logs (synchronous).  
5ï¸âƒ£ Microtasks execute:
   - `"C"` logs.  
   - `"D"` logs.  
6ï¸âƒ£ Macrotask executes:
   - `"B"` logs.  

âœ” **Final Output:**  
```
A
E
C
D
B
```

---

# **âœ… Step 7: `setImmediate` vs `setTimeout(0)` in Node.js**
```javascript
const fs = require("fs");

fs.readFile(__filename, () => {
    setTimeout(() => console.log("setTimeout"), 0);
    setImmediate(() => console.log("setImmediate"));
});
```
### **ðŸ”¹ Execution Order**
- `fs.readFile()` moves to the **I/O phase**.
- **After I/O**, `setImmediate` executes first **before `setTimeout(0)`**.
âœ” **Final Output:**  
```
setImmediate
setTimeout
```

---

# **ðŸš€ Summary**
âœ” JavaScript executes **synchronous code first**.  
âœ” **Microtasks (Promises) run before macrotasks (setTimeout).**  
âœ” The **Event Loop cycles**, handling one macrotask at a time.  
âœ” **`setImmediate` runs before `setTimeout(0)` after I/O in Node.js.**  
âœ” **UI updates occur between Event Loop iterations.**

---

ðŸ”¥ **Understanding the Event Loop helps write efficient, non-blocking JavaScript!** ðŸš€