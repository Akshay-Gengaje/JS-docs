# How does JavaScript handle stack overflow with recursive functions?

JavaScript **manages function calls using a call stack**, a data structure that keeps track of function execution. When a **recursive function** runs indefinitely or exceeds the call stack limit, **JavaScript throws a "Maximum call stack size exceeded" error**.

---

## **‚úÖ How Stack Overflow Occurs in Recursive Functions**  
A **recursive function** is a function that calls itself until it reaches a **base case**.

### **Example of a Stack Overflow Error**
```javascript
function infiniteRecursion() {
    return infiniteRecursion(); // No base case!
}

infiniteRecursion(); // ‚ùå Error: Maximum call stack size exceeded
```
‚úî Since there is **no base case**, the function **keeps adding calls** to the stack **indefinitely**, causing a **stack overflow**.

---

### **‚úÖ Understanding the Call Stack in Recursive Functions**
JavaScript uses a **call stack** to manage function execution. Each function call is **pushed** onto the stack, and when it returns, it is **popped** off.

#### **Example of a Normal Recursive Function**
```javascript
function countdown(n) {
    if (n <= 0) return;
    console.log(n);
    countdown(n - 1);
}

countdown(5);
```
‚úî **Call Stack Execution:**
```
countdown(5)
countdown(4)
countdown(3)
countdown(2)
countdown(1)
countdown(0) // Base case reached, function calls start returning
```
‚úî The function **stops at `n === 0` and unwinds the stack**, preventing overflow.

---

## **‚úÖ When Does Stack Overflow Happen?**
Even with a **base case**, if recursion goes too deep (e.g., for large input sizes), it can **exceed JavaScript‚Äôs stack limit**.

```javascript
function deepRecursion(n) {
    if (n === 0) return;
    deepRecursion(n - 1);
}

deepRecursion(100000); // ‚ùå Error: Maximum call stack size exceeded
```
üìå **Stack limit depends on the JavaScript engine (e.g., V8 in Chrome has ~10,000-50,000 calls).**

---

## **‚úÖ How to Prevent Stack Overflow in Recursion**
### **1Ô∏è‚É£ Use Tail Recursion (Only in Certain JS Engines)**
**Tail recursion optimization (TCO)** allows JavaScript engines to optimize recursive functions **without growing the call stack**.  
üìå **V8 (Chrome, Node.js) does NOT support TCO**, but Safari does.

```javascript
"use strict"; // Required for TCO in supported engines

function tailRecursion(n, acc = 1) {
    if (n === 0) return acc;
    return tailRecursion(n - 1, n * acc); // Tail position
}

console.log(tailRecursion(5)); // 120
```
‚úî **Why it works?**  
- **Tail call optimization (TCO)** reuses the current stack frame instead of adding a new one.  
- **Not supported in Chrome or Node.js**.

---

### **2Ô∏è‚É£ Convert Recursion to Iteration (Loop)**
A **loop-based approach** avoids the call stack issue completely.

```javascript
function iterativeFactorial(n) {
    let result = 1;
    for (let i = n; i > 0; i--) {
        result *= i;
    }
    return result;
}

console.log(iterativeFactorial(5)); // 120
```
‚úî **Loops prevent stack overflow** because they don‚Äôt use recursive function calls.

---

### **3Ô∏è‚É£ Use a Stack Data Structure (Manual Recursion)**
Instead of using **function calls**, simulate recursion using a **stack (array)**.

```javascript
function iterativeRecursion(n) {
    let stack = [n];

    while (stack.length > 0) {
        let num = stack.pop();
        if (num === 0) continue;
        stack.push(num - 1);
    }
}

iterativeRecursion(100000); // ‚úÖ No stack overflow
```
‚úî This **manually manages recursion**, preventing uncontrolled stack growth.

---

### **4Ô∏è‚É£ Use setTimeout() for Large Recursions (Trampoline Technique)**
JavaScript‚Äôs **event loop** resets the call stack between asynchronous calls.

```javascript
function asyncRecursion(n) {
    if (n === 0) return;
    setTimeout(() => asyncRecursion(n - 1), 0);
}

asyncRecursion(100000); // ‚úÖ No stack overflow
```
‚úî **Why it works?**  
- **setTimeout() defers execution**, breaking recursion into smaller chunks.  
- The **call stack resets** between calls.

---

## **‚úÖ Key Takeaways**
| Approach | Prevents Stack Overflow? | When to Use |
|----------|-----------------|----------------|
| **Tail Recursion** | ‚úÖ Yes (if supported) | Works in Safari but **not V8 (Chrome, Node.js)** |
| **Iteration (Loop)** | ‚úÖ Yes | Best for performance and avoiding stack growth |
| **Manual Stack (Array)** | ‚úÖ Yes | When recursion is needed but stack growth is an issue |
| **setTimeout() (Trampoline)** | ‚úÖ Yes | When deep recursion is needed without blocking the thread |

---

### **üöÄ Final Thoughts**
‚úî **JavaScript has a call stack limit** (~10,000 - 50,000 calls).  
‚úî **Infinite recursion** causes **"Maximum call stack size exceeded"**.  
‚úî **Use iteration, tail recursion, manual stack, or async techniques** to avoid stack overflow.  
